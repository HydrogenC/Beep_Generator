#include "BGScriptReader.h"

const UInt32 hzTable[] = {
	27u, 29u, 31u,
	33u, 35u, 37u, 39u, 41u, 44u, 46u, 49u, 52u, 55u, 58u, 62u,
	65u, 69u, 73u, 78u, 82u, 87u, 92u, 98u, 104u, 110u, 117u, 123u,
	131u, 139u, 147u, 156u, 165u, 175u, 185u, 196u, 208u, 220u, 233u, 247u,
	262u, 277u, 294u, 311u, 329u, 349u, 370u, 392u, 415u, 440u, 466u, 494u,
	523u, 554u, 587u, 622u, 659u, 698u, 740u, 784u, 831u, 880u, 932u, 988u,
	1047u, 1109u, 1175u, 1245u, 1319u, 1397u, 1480u, 1568u, 1661u, 1760u, 1865u, 1976u,
	2093u, 2217u, 2349u, 2489u, 2637u, 2794u, 2960u, 3135u, 3322u, 3520u, 3729u, 3951u,
	4186u
};

String sourceFile, outFile;
array<Int16, 7> regModify = { 0,0,0,0,0,0,0 };
UInt32 forthNoteLen = 500;
IFStream fin;
OFStream fout;

vector<String> split(String source, Char seperator) {
	auto findAndReturn = [&](Int32 & save) {
		save = source.find(seperator);
		return save;
	};

	vector<String> res = vector<String>();
	Int32 index = 0;
	while (findAndReturn(index) != String::npos) {
		if (source.substr(0, index) != L"") {
			res.push_back(source.substr(0, index));
		}
		source = source.substr(index + 1);
	}
	if (source != L"") {
		res.push_back(source);
	}
	return res;
}

Command::Command(String token, function<void(String)> func) {
	VThis.token = token;
	VThis.func = func;
}

Boolean Command::Execute(String parms) {
	try {
		func(parms);
		return true;
	}
	catch (String e) {
		wcout << e << endl;
		return false;
	}
}

String Command::getToken() {
	return token;
}

array<Command, 8> cmdList = {
	Command(String(L"el"), [&](String parms) {
		fout << L"\r\n";
	}),
	Command(String(L"pr"), [&](String parms) {
		fout << parms << "\r\n";
		wcout << L"Printed \"" << parms << L"\" to file. " << endl;
	}),
	Command(String(L"//"), [&](String parms) {
		return;
	}),
	Command(String(L"out"), [&](String parms) {
		outFile = parms;
		fout.open(outFile);
		fout << L"# Generated by DBeepGenerator\r\n";
		wcout << L"Out file set to " << parms << ". " << endl;
	}),
	Command(String(L"bpm"), [&](String parms) {
		UInt32 bpm = SStreamConvert<String,UInt32>(parms);
		forthNoteLen = 60000u / bpm;
		wcout << "BPM set to " << parms << ". " << endl;
	}),
	Command(String(L"sign"), [&](String parms) {
		StrSwitch(parms) {
			case StrCase(L"C"):
			case StrCase(L"a"):
				break;
			case StrCase(L"C#"):
			case StrCase(L"a#"):
				regModify = { 1, 1, 1, 1, 1, 1, 1 };
				break;
			case StrCase(L"Db"):
			case StrCase(L"bb"):
				regModify = { 0, -1, -1, 0, -1, -1, -1 };
				break;
			case StrCase(L"D"):
			case StrCase(L"b"):
				regModify = { 1, 0, 0, 1, 0, 0, 0 };
				break;
			case StrCase(L"Eb"):
			case StrCase(L"c"):
				regModify = { 0, 0, -1, 0, 0, -1, -1 };
				break;
			case StrCase(L"E"):
			case StrCase(L"c#"):
				regModify = { 1, 1, 0, 1, 1, 0, 0 };
				break;
			case StrCase(L"F"):
			case StrCase(L"d"):
				regModify = { 0, 0, 0, 0, 0, 0, -1 };
				break;
			case StrCase(L"F#"):
			case StrCase(L"d#"):
				regModify = { 1, 1, 1, 1, 1, 1, 0 };
				break;
			case StrCase(L"G"):
			case StrCase(L"e"):
				regModify = { 0, 0, 0, 1, 0, 0, 0 };
				break;
			case StrCase(L"Ab"):
			case StrCase(L"f"):
				regModify = { 0, -1, -1, 0, 0, -1, -1 };
				break;
			case StrCase(L"A"):
			case StrCase(L"f#"):
				regModify = { 1, 0, 0, 1, 1, 0, 0 };
				break;
			case StrCase(L"Bb"):
			case StrCase(L"g"):
				regModify = { 0, 0, -1, 0, 0, 0, -1 };
				break;
			case StrCase(L"B"):
			case StrCase(L"g#"):
				regModify = { 1, 1, 0, 1, 1, 1, 0 };
				break;
			case StrCase(L"Cb"):
			case StrCase(L"ab"):
				regModify = { -1, -1, -1, -1, -1, -1, -1 };
				break;
			default:
				break;
			}
			wcout << L"Sign changed to " << parms << L". " << endl;
		}),
		Command(String(L"note"), [&](String parms) {
			vector<String> arguments = split(parms,L' ');
			UInt32 timeNote = identifyTime(arguments[0]);
			UInt32 pitchIndex = identifyPitch(arguments[1]);
			fout << L"Beep(" << SStreamConvert<UInt32,String>(hzTable[pitchIndex]) << L", " << SStreamConvert<UInt32, String>(timeNote) << L");\r\n";
			wcout << L"Identified note: " << parms << endl;
		}),
		Command(String(L"br"), [&](String parms) {
			UInt32 timeBr = identifyTime(parms);
			fout << L"Sleep(" << SStreamConvert<UInt32, String>(timeBr) << L");\r\n";
			wcout << L"Identified break: " << parms << endl;
		})
};

UInt32 identifyTime(String time) {
	vector<String> noteList = split(time, L'-');
	UInt32 lenInForthNote = 0;
	for (String i : noteList) {
		lenInForthNote += identifyNoteLen(i);
	}
	return lenInForthNote;
}

UInt32 identifyNoteLen(String noteType) {
	UInt32 times = 0;
	for (; times < 10; times += 1) {
		if (noteType == SStreamConvert<UInt32, String>(pow(2u, times))) {
			break;
		}
	}
	return (forthNoteLen * 4u) / pow(2u, times);
}

UInt32 identifyPitch(String pitch) {
	UInt32 num = SStreamConvert<String, UInt32>(pitch.substr(pitch.length() - 1));
	UInt32 pitchId = 0;
	UInt32 signId = 0;
	String pitchName = pitch.substr(0, pitch.length() - 1);
	StrSwitch(pitchName) {
	case StrCase(L"A"):
		pitchId = 0;
		signId = 0;
		break;
	case StrCase(L"A#"):
		pitchId = 1;
		signId = 0;
		break;
	case StrCase(L"Bb"):
		pitchId = 1;
		signId = 1;
		break;
	case StrCase(L"B"):
		pitchId = 2;
		signId = 1;
		break;
	case StrCase(L"C"):
		pitchId = 3;
		signId = 2;
		break;
	case StrCase(L"C#"):
		pitchId = 4;
		signId = 2;
		break;
	case StrCase(L"Db"):
		pitchId = 4;
		signId = 3;
		break;
	case StrCase(L"D"):
		pitchId = 5;
		signId = 3;
		break;
	case StrCase(L"D#"):
		pitchId = 6;
		signId = 3;
		break;
	case StrCase(L"Eb"):
		pitchId = 6;
		signId = 4;
		break;
	case StrCase(L"E"):
		pitchId = 7;
		signId = 4;
		break;
	case StrCase(L"F"):
		pitchId = 8;
		signId = 5;
		break;
	case StrCase(L"F#"):
		pitchId = 9;
		signId = 5;
		break;
	case StrCase(L"Gb"):
		pitchId = 9;
		signId = 6;
		break;
	case StrCase(L"G"):
		pitchId = 10;
		signId = 6;
		break;
	case StrCase(L"G#"):
		pitchId = 11;
		signId = 6;
		break;
	case StrCase(L"Ab"):
		pitchId = 11;
		signId = 0;
		break;
	default:
		break;
	}
	pitchId += regModify[signId];
	return num * 12 + pitchId;
}
