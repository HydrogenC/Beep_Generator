#include "BGScriptReader.h"

const UInt32 hzTable[] = {
	27u, 29u, 31u,
	33u, 35u, 37u, 39u, 41u, 44u, 46u, 49u, 52u, 55u, 58u, 62u,
	65u, 69u, 73u, 78u, 82u, 87u, 92u, 98u, 104u, 110u, 117u, 123u,
	131u, 139u, 147u, 156u, 165u, 175u, 185u, 196u, 208u, 220u, 233u, 247u,
	262u, 277u, 294u, 311u, 329u, 349u, 370u, 392u, 415u, 440u, 466u, 494u,
	523u, 554u, 587u, 622u, 659u, 698u, 740u, 784u, 831u, 880u, 932u, 988u,
	1047u, 1109u, 1175u, 1245u, 1319u, 1397u, 1480u, 1568u, 1661u, 1760u, 1865u, 1976u,
	2093u, 2217u, 2349u, 2489u, 2637u, 2794u, 2960u, 3135u, 3322u, 3520u, 3729u, 3951u,
	4186u
};

String sourceFile, outFile;
array<Int16, 7> regModify = { 0,0,0,0,0,0,0 };
UInt16 forthNoteLen = 500;
IFStream fin;
OFStream fout;

Command cmdList[] = {
	Command(String(L"el"), [&](String parms) {
		fout << L"\r\n";
	}),
	Command(String(L"pr"), [&](String parms) {
		fout << parms << "\r\n";
		wcout << L"Printed \"" << parms << L"\" to file. " << endl;
	}),
	Command(String(L"//"), [&](String parms) {
		return;
	}),
	Command(String(L"out"), [&](String parms) {
		outFile = parms;
		fout = OFStream(outFile);
		fout << L"# Generated by DBeepGenerator\r\n";
		wcout << L"Out file set to " << parms << ". " << endl;
	}),
	Command(String(L"bpm"), [&](String parms) {
		UInt16 bpm = SStreamConvert<String,UInt16>(parms);
		forthNoteLen = 60000u / bpm;
		wcout << "BPM set to " << parms << ". " << endl;
	}),
		Command(String(L"sign"), [&](String parms) {
			StrSwitch(parms) {
			case StrCase(L"C"):
			case StrCase(L"a"):
				break;
			case StrCase(L"C#"):
			case StrCase(L"a#"):
				regModify = { 1, 1, 1, 1, 1, 1, 1 };
				break;
			case StrCase(L"Db"):
			case StrCase(L"bb"):
				regModify = { 0, -1, -1, 0, -1, -1, -1 };
				break;
			case StrCase(L"D"):
			case StrCase(L"b"):
				regModify = { 1, 0, 0, 1, 0, 0, 0 };
				break;
			case StrCase(L"Eb"):
			case StrCase(L"c"):
				regModify = { 0, 0, -1, 0, 0, -1, -1 };
				break;
			case StrCase(L"E"):
			case StrCase(L"c#"):
				regModify = { 1, 1, 0, 1, 1, 0, 0 };
				break;
			case StrCase(L"F"):
			case StrCase(L"d"):
				regModify = { 0, 0, 0, 0, 0, 0, -1 };
				break;
			case StrCase(L"F#"):
			case StrCase(L"d#"):
				regModify = { 1, 1, 1, 1, 1, 1, 0 };
				break;
			case StrCase(L"G"):
			case StrCase(L"e"):
				regModify = { 0, 0, 0, 1, 0, 0, 0 };
				break;
			case StrCase(L"Ab"):
			case StrCase(L"f"):
				regModify = { 0, -1, -1, 0, 0, -1, -1 };
				break;
			case StrCase(L"A"):
			case StrCase(L"f#"):
				regModify = { 1, 0, 0, 1, 1, 0, 0 };
				break;
			case StrCase(L"Bb"):
			case StrCase(L"g"):
				regModify = { 0, 0, -1, 0, 0, 0, -1 };
				break;
			case StrCase(L"B"):
			case StrCase(L"g#"):
				regModify = { 1, 1, 0, 1, 1, 1, 0 };
				break;
			case StrCase(L"Cb"):
			case StrCase(L"ab"):
				regModify = { -1, -1, -1, -1, -1, -1, -1 };
				break;
			default:
				break;
			}
			fout << L"Sign changed to " << parms << L". ";
		}),
		/*
		Command("note", function(string parms){
			string[] arguments = parms.split(' ');
			uint timeNote = identifyTime(arguments[0]);
			uint pitchIndex = identifyPitch(arguments[1]);
			std.file.append(outFile, "Beep("~to!(string)(hzTable[pitchIndex])~", "~to!(string)(timeNote)~");\r\n");
			writeln("Identified note: "~parms);
		}),
		Command("br", function(string parms){
			uint timeBr = identifyTime(parms);
			std.file.append(outFile, "Sleep("~to!(string)(timeBr)~");\r\n");
			writeln("Identified break: "~parms);
		})
		*/
};

Command::Command(String token, function<void(String)> func) {
	VThis.token = token;
	VThis.func = func;
}

Boolean Command::Execute(String parms) {
	try {
		func(parms);
		return true;
	}
	catch (String e) {
		wcout << e << endl;
		return false;
	}
}

String Command::getToken() {
	return token;
}
